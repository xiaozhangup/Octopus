--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -1,11 +_,30 @@
 package net.minecraft.world.entity;
 
+import ca.spottedleaf.moonrise.common.util.ThreadUnsafeRandom;
+import ca.spottedleaf.moonrise.common.util.TickThread;
+import ca.spottedleaf.moonrise.common.util.WorldUtil;
+import ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity;
+import ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel;
+import ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkData;
+import ca.spottedleaf.moonrise.patches.collisions.CollisionUtil;
+import ca.spottedleaf.moonrise.patches.collisions.block.CollisionBlockState;
+import ca.spottedleaf.moonrise.patches.collisions.shape.CollisionVoxelShape;
+import ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity;
+import com.destroystokyo.paper.event.entity.EntityTeleportEndGatewayEvent;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.google.common.collect.ImmutableList.Builder;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.configuration.GlobalConfiguration;
+import io.papermc.paper.configuration.type.number.IntOr;
+import io.papermc.paper.entity.activation.ActivationRange;
+import io.papermc.paper.entity.activation.ActivationType;
+import io.papermc.paper.event.entity.EntityKnockbackEvent;
+import io.papermc.paper.event.entity.EntityPushedByEntityAttackEvent;
+import io.papermc.paper.event.player.PlayerUntrackEntityEvent;
+import io.papermc.paper.util.SizeLimitedSet;
 import it.unimi.dsi.fastutil.floats.FloatArraySet;
 import it.unimi.dsi.fastutil.floats.FloatArrays;
 import it.unimi.dsi.fastutil.floats.FloatSet;
@@ -13,6 +_,7 @@
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.objects.Object2DoubleArrayMap;
 import it.unimi.dsi.fastutil.objects.Object2DoubleMap;
+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ReferenceArraySet;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -25,8 +_,10 @@
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BiConsumer;
+import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 import net.minecraft.BlockUtil;
 import net.minecraft.CrashReport;
@@ -44,19 +_,12 @@
 import net.minecraft.core.SectionPos;
 import net.minecraft.core.particles.BlockParticleOption;
 import net.minecraft.core.particles.ParticleTypes;
-import net.minecraft.nbt.CompoundTag;
-import net.minecraft.nbt.DoubleTag;
-import net.minecraft.nbt.FloatTag;
-import net.minecraft.nbt.ListTag;
-import net.minecraft.nbt.StringTag;
+import net.minecraft.nbt.*;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.HoverEvent;
 import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
-import net.minecraft.network.protocol.game.ClientGamePacketListener;
-import net.minecraft.network.protocol.game.ClientboundAddEntityPacket;
-import net.minecraft.network.protocol.game.ClientboundTeleportEntityPacket;
-import net.minecraft.network.protocol.game.VecDeltaCodec;
+import net.minecraft.network.protocol.game.*;
 import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.network.syncher.EntityDataSerializers;
 import net.minecraft.network.syncher.SyncedDataHolder;
@@ -64,10 +_,7 @@
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
-import net.minecraft.server.level.ServerEntity;
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.server.level.TicketType;
+import net.minecraft.server.level.*;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.sounds.SoundSource;
@@ -85,6 +_,9 @@
 import net.minecraft.world.Nameable;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.damagesource.DamageSources;
+import net.minecraft.world.entity.animal.AbstractFish;
+import net.minecraft.world.entity.animal.Animal;
+import net.minecraft.world.entity.decoration.HangingEntity;
 import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.entity.projectile.Projectile;
@@ -93,28 +_,21 @@
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
-import net.minecraft.world.level.BlockGetter;
-import net.minecraft.world.level.ChunkPos;
-import net.minecraft.world.level.ClipContext;
-import net.minecraft.world.level.Explosion;
-import net.minecraft.world.level.ItemLike;
-import net.minecraft.world.level.Level;
-import net.minecraft.world.level.block.Block;
-import net.minecraft.world.level.block.Blocks;
-import net.minecraft.world.level.block.FenceGateBlock;
-import net.minecraft.world.level.block.HoneyBlock;
-import net.minecraft.world.level.block.Mirror;
-import net.minecraft.world.level.block.Portal;
-import net.minecraft.world.level.block.RenderShape;
-import net.minecraft.world.level.block.Rotation;
-import net.minecraft.world.level.block.SoundType;
+import net.minecraft.world.level.*;
+import net.minecraft.world.level.block.*;
+import net.minecraft.world.level.block.entity.TheEndGatewayBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.border.WorldBorder;
+import net.minecraft.world.level.chunk.ChunkSource;
+import net.minecraft.world.level.chunk.LevelChunkSection;
+import net.minecraft.world.level.chunk.PalettedContainer;
+import net.minecraft.world.level.chunk.status.ChunkStatus;
 import net.minecraft.world.level.entity.EntityAccess;
 import net.minecraft.world.level.entity.EntityInLevelCallback;
 import net.minecraft.world.level.gameevent.DynamicGameEventListener;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.levelgen.Heightmap;
+import net.minecraft.world.level.levelgen.RandomSupport;
 import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.material.PushReaction;
@@ -133,9 +_,38 @@
 import net.minecraft.world.scores.PlayerTeam;
 import net.minecraft.world.scores.ScoreHolder;
 import net.minecraft.world.scores.Team;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.PortalType;
+import org.bukkit.World;
+import org.bukkit.block.BlockFace;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.craftbukkit.block.CraftEndGateway;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.event.CraftPortalEvent;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.craftbukkit.inventory.CraftItemType;
+import org.bukkit.craftbukkit.util.CraftLocation;
+import org.bukkit.craftbukkit.util.CraftVector;
+import org.bukkit.entity.Hanging;
+import org.bukkit.entity.Vehicle;
+import org.bukkit.event.entity.*;
+import org.bukkit.event.hanging.HangingBreakByEntityEvent;
+import org.bukkit.event.player.PlayerTeleportEvent;
+import org.bukkit.event.player.PlayerUnleashEntityEvent;
+import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
+import org.bukkit.event.vehicle.VehicleEnterEvent;
+import org.bukkit.event.vehicle.VehicleExitEvent;
+import org.bukkit.plugin.PluginManager;
+import org.bukkit.projectiles.ProjectileSource;
+import org.bukkit.util.Vector;
 import org.slf4j.Logger;
 
-public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess, ScoreHolder, ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity, ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity {  // Paper - rewrite chunk system // Paper - optimise entity tracker
+public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess, ScoreHolder, ChunkSystemEntity, EntityTrackerEntity {  // Paper - rewrite chunk system // Paper - optimise entity tracker
 
     // CraftBukkit start
     private static final int CURRENT_LEVEL = 2;
@@ -147,9 +_,9 @@
     // Paper start - Share random for entities to make them more random
     public static RandomSource SHARED_RANDOM = new RandomRandomSource();
     // Paper start - replace random
-    private static final class RandomRandomSource extends ca.spottedleaf.moonrise.common.util.ThreadUnsafeRandom {
+    private static final class RandomRandomSource extends ThreadUnsafeRandom {
         public RandomRandomSource() {
-            this(net.minecraft.world.level.levelgen.RandomSupport.generateUniqueSeed());
+            this(RandomSupport.generateUniqueSeed());
         }
 
         public RandomRandomSource(long seed) {
@@ -172,17 +_,17 @@
         // Paper - replace random
     }
     // Paper end - Share random for entities to make them more random
-    public org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason spawnReason; // Paper - Entity#getEntitySpawnReason
+    public CreatureSpawnEvent.SpawnReason spawnReason; // Paper - Entity#getEntitySpawnReason
 
     public boolean collisionLoadChunks = false; // Paper
-    private @Nullable org.bukkit.craftbukkit.entity.CraftEntity bukkitEntity;
+    private @Nullable CraftEntity bukkitEntity;
 
-    public org.bukkit.craftbukkit.entity.CraftEntity getBukkitEntity() {
+    public CraftEntity getBukkitEntity() {
         if (this.bukkitEntity == null) {
             // Paper start - Folia schedulers
             synchronized (this) {
                 if (this.bukkitEntity == null) {
-                    return this.bukkitEntity = org.bukkit.craftbukkit.entity.CraftEntity.getEntity(this.level.getCraftServer(), this);
+                    return this.bukkitEntity = CraftEntity.getEntity(this.level.getCraftServer(), this);
                 }
             }
             // Paper end - Folia schedulers
@@ -190,7 +_,7 @@
         return this.bukkitEntity;
     }
     // Paper start
-    public @Nullable org.bukkit.craftbukkit.entity.CraftEntity getBukkitEntityRaw() {
+    public @Nullable CraftEntity getBukkitEntityRaw() {
         return this.bukkitEntity;
     }
     // Paper end
@@ -243,7 +_,7 @@
     public boolean hurtMarked;
     protected Vec3 stuckSpeedMultiplier = Vec3.ZERO;
     @Nullable
-    private Entity.RemovalReason removalReason;
+    private RemovalReason removalReason;
     public static final float DEFAULT_BB_WIDTH = 0.6F;
     public static final float DEFAULT_BB_HEIGHT = 1.8F;
     public float moveDist;
@@ -292,7 +_,7 @@
     protected UUID uuid = Mth.createInsecureUUID(this.random);
     protected String stringUUID = this.uuid.toString();
     private boolean hasGlowingTag;
-    private final Set<String> tags = new io.papermc.paper.util.SizeLimitedSet<>(new it.unimi.dsi.fastutil.objects.ObjectOpenHashSet<>(), MAX_ENTITY_TAG_COUNT); // Paper - fully limit tag size - replace set impl
+    private final Set<String> tags = new SizeLimitedSet<>(new ObjectOpenHashSet<>(), MAX_ENTITY_TAG_COUNT); // Paper - fully limit tag size - replace set impl
     private final double[] pistonDeltas = new double[]{0.0, 0.0, 0.0};
     private long pistonDeltasGameTime;
     private EntityDimensions dimensions;
@@ -306,7 +_,7 @@
     public boolean hasVisualFire;
     @Nullable
     private BlockState inBlockState = null;
-    private final List<Entity.Movement> movementThisTick = new ArrayList<>();
+    private final List<Movement> movementThisTick = new ArrayList<>();
     private final Set<BlockState> blocksInside = new ReferenceArraySet<>();
     private final LongSet visitedBlocks = new LongOpenHashSet();
     // CraftBukkit start
@@ -318,7 +_,7 @@
     public boolean generation;
     public int maxAirTicks = this.getDefaultMaxAirSupply(); // CraftBukkit - SPIGOT-6907: re-implement LivingEntity#setMaximumAir()
     @Nullable // Paper - Refresh ProjectileSource for projectiles
-    public org.bukkit.projectiles.ProjectileSource projectileSource; // For projectiles only
+    public ProjectileSource projectileSource; // For projectiles only
     public boolean lastDamageCancelled; // SPIGOT-5339, SPIGOT-6252, SPIGOT-6777: Keep track if the event was canceled
     public boolean persistentInvisibility = false;
     public BlockPos lastLavaContact;
@@ -329,15 +_,15 @@
     public boolean fromNetherPortal; // Paper - Add option to nerf pigmen from nether portals
     public boolean spawnedViaMobSpawner; // Paper - Yes this name is similar to above, upstream took the better one
     // Paper start - Entity origin API
-    @javax.annotation.Nullable
-    private org.bukkit.util.Vector origin;
-    @javax.annotation.Nullable
+    @Nullable
+    private Vector origin;
+    @Nullable
     private UUID originWorld;
     public boolean freezeLocked = false; // Paper - Freeze Tick Lock API
     public boolean fixedPose = false; // Paper - Expand Pose API
     private final int despawnTime; // Paper - entity despawn time limit
     public int totalEntityAge; // Paper - age-like counter for all entities
-    public final io.papermc.paper.entity.activation.ActivationType activationType = io.papermc.paper.entity.activation.ActivationType.activationTypeFor(this); // Paper - EAR 2/tracking ranges
+    public final ActivationType activationType = ActivationType.activationTypeFor(this); // Paper - EAR 2/tracking ranges
     // Paper start - EAR 2
     public final boolean defaultActivationState;
     public long activatedTick = Integer.MIN_VALUE;
@@ -348,17 +_,17 @@
     }
     // Paper end - EAR 2
 
-    public void setOrigin(@javax.annotation.Nonnull org.bukkit.Location location) {
+    public void setOrigin(@Nonnull Location location) {
         this.origin = location.toVector();
         this.originWorld = location.getWorld().getUID();
     }
 
-    @javax.annotation.Nullable
-    public org.bukkit.util.Vector getOriginVector() {
+    @Nullable
+    public Vector getOriginVector() {
         return this.origin != null ? this.origin.clone() : null;
     }
 
-    @javax.annotation.Nullable
+    @Nullable
     public UUID getOriginWorld() {
         return this.originWorld;
     }
@@ -374,8 +_,8 @@
     // Paper end
     // Paper start - rewrite chunk system
     private final boolean isHardColliding = this.moonrise$isHardCollidingUncached();
-    private net.minecraft.server.level.FullChunkStatus chunkStatus;
-    private ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkData chunkData;
+    private FullChunkStatus chunkStatus;
+    private ChunkData chunkData;
     private int sectionX = Integer.MIN_VALUE;
     private int sectionY = Integer.MIN_VALUE;
     private int sectionZ = Integer.MIN_VALUE;
@@ -387,22 +_,22 @@
     }
 
     @Override
-    public final net.minecraft.server.level.FullChunkStatus moonrise$getChunkStatus() {
+    public final FullChunkStatus moonrise$getChunkStatus() {
         return this.chunkStatus;
     }
 
     @Override
-    public final void moonrise$setChunkStatus(final net.minecraft.server.level.FullChunkStatus status) {
+    public final void moonrise$setChunkStatus(final FullChunkStatus status) {
         this.chunkStatus = status;
     }
 
     @Override
-    public final ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkData moonrise$getChunkData() {
+    public final ChunkData moonrise$getChunkData() {
         return this.chunkData;
     }
 
     @Override
-    public final void moonrise$setChunkData(final ca.spottedleaf.moonrise.patches.chunk_system.level.chunk.ChunkData chunkData) {
+    public final void moonrise$setChunkData(final ChunkData chunkData) {
         this.chunkData = chunkData;
     }
 
@@ -462,8 +_,8 @@
         for (int i = 0, len = voxels.size(); i < len; ++i) {
             final VoxelShape shape = voxels.get(i);
 
-            final double[] yCoords = ((ca.spottedleaf.moonrise.patches.collisions.shape.CollisionVoxelShape)shape).moonrise$rootCoordinatesY();
-            final double yOffset = ((ca.spottedleaf.moonrise.patches.collisions.shape.CollisionVoxelShape)shape).moonrise$offsetY();
+            final double[] yCoords = ((CollisionVoxelShape)shape).moonrise$rootCoordinatesY();
+            final double yOffset = ((CollisionVoxelShape)shape).moonrise$offsetY();
 
             for (final double yUnoffset : yCoords) {
                 final double y = yUnoffset + yOffset;
@@ -503,15 +_,15 @@
     }
     // Paper end - optimise collisions
     // Paper start - optimise entity tracker
-    private net.minecraft.server.level.ChunkMap.TrackedEntity trackedEntity;
+    private ChunkMap.TrackedEntity trackedEntity;
 
     @Override
-    public final net.minecraft.server.level.ChunkMap.TrackedEntity moonrise$getTrackedEntity() {
+    public final ChunkMap.TrackedEntity moonrise$getTrackedEntity() {
         return this.trackedEntity;
     }
 
     @Override
-    public final void moonrise$setTrackedEntity(final net.minecraft.server.level.ChunkMap.TrackedEntity trackedEntity) {
+    public final void moonrise$setTrackedEntity(final ChunkMap.TrackedEntity trackedEntity) {
         this.trackedEntity = trackedEntity;
     }
 
@@ -532,7 +_,7 @@
         this.chunkPosition = ChunkPos.ZERO;
         // Paper start - EAR 2
         if (level != null) {
-            this.defaultActivationState = io.papermc.paper.entity.activation.ActivationRange.initializeEntityActivationState(this, level.spigotConfig);
+            this.defaultActivationState = ActivationRange.initializeEntityActivationState(this, level.spigotConfig);
         } else {
             this.defaultActivationState = false;
         }
@@ -550,7 +_,7 @@
         this.entityData = builder.build();
         this.setPos(0.0, 0.0, 0.0);
         this.eyeHeight = this.dimensions.eyeHeight();
-        this.despawnTime = type == EntityType.PLAYER ? -1 : level.paperConfig().entities.spawning.despawnTime.getOrDefault(type, io.papermc.paper.configuration.type.number.IntOr.Disabled.DISABLED).or(-1); // Paper - entity despawn time limit
+        this.despawnTime = type == EntityType.PLAYER ? -1 : level.paperConfig().entities.spawning.despawnTime.getOrDefault(type, IntOr.Disabled.DISABLED).or(-1); // Paper - entity despawn time limit
     }
 
     public boolean isColliding(BlockPos pos, BlockState state) {
@@ -618,7 +_,7 @@
     }
 
     public void kill(ServerLevel level) {
-        this.remove(Entity.RemovalReason.KILLED, org.bukkit.event.entity.EntityRemoveEvent.Cause.DEATH); // CraftBukkit - add Bukkit remove cause
+        this.remove(RemovalReason.KILLED, EntityRemoveEvent.Cause.DEATH); // CraftBukkit - add Bukkit remove cause
         this.gameEvent(GameEvent.ENTITY_DIE);
     }
 
@@ -627,8 +_,8 @@
         this.discard(null);
     }
 
-    public final void discard(org.bukkit.event.entity.EntityRemoveEvent.Cause cause) {
-        this.remove(Entity.RemovalReason.DISCARDED, cause);
+    public final void discard(EntityRemoveEvent.Cause cause) {
+        this.remove(RemovalReason.DISCARDED, cause);
         // CraftBukkit end
     }
 
@@ -643,24 +_,24 @@
         List<SynchedEntityData.DataValue<?>> list = this.entityData.packAll(); // Paper - Update EVERYTHING not just not default
 
         if (list != null && to.getBukkitEntity().canSee(this.getBukkitEntity())) { // Paper
-            to.connection.send(new net.minecraft.network.protocol.game.ClientboundSetEntityDataPacket(this.getId(), list));
+            to.connection.send(new ClientboundSetEntityDataPacket(this.getId(), list));
         }
     }
     // CraftBukkit end
     // Paper start
     // This method should only be used if the data of an entity could have become desynced
     // due to interactions on the client.
-    public void resendPossiblyDesyncedEntityData(net.minecraft.server.level.ServerPlayer player) {
+    public void resendPossiblyDesyncedEntityData(ServerPlayer player) {
         if (player.getBukkitEntity().canSee(this.getBukkitEntity())) {
-            ServerLevel world = (net.minecraft.server.level.ServerLevel)this.level();
-            net.minecraft.server.level.ChunkMap.TrackedEntity tracker = world == null ? null : world.getChunkSource().chunkMap.entityMap.get(this.getId());
+            ServerLevel world = (ServerLevel)this.level();
+            ChunkMap.TrackedEntity tracker = world == null ? null : world.getChunkSource().chunkMap.entityMap.get(this.getId());
             if (tracker == null) {
                 return;
             }
-            final net.minecraft.server.level.ServerEntity serverEntity = tracker.serverEntity;
-            final List<net.minecraft.network.protocol.Packet<? super net.minecraft.network.protocol.game.ClientGamePacketListener>> list = new java.util.ArrayList<>();
+            final ServerEntity serverEntity = tracker.serverEntity;
+            final List<Packet<? super ClientGamePacketListener>> list = new ArrayList<>();
             serverEntity.sendPairingData(player, list::add);
-            player.connection.send(new net.minecraft.network.protocol.game.ClientboundBundlePacket(list));
+            player.connection.send(new ClientboundBundlePacket(list));
         }
     }
 
@@ -670,13 +_,13 @@
             return;
         }
 
-        final List<SynchedEntityData.DataValue<?>> values = new java.util.ArrayList<>(keys.size());
+        final List<SynchedEntityData.DataValue<?>> values = new ArrayList<>(keys.size());
         for (final EntityDataAccessor<?> key : keys) {
             final SynchedEntityData.DataItem<?> synchedValue = this.entityData.getItem(key);
             values.add(synchedValue.value());
         }
 
-        to.connection.send(new net.minecraft.network.protocol.game.ClientboundSetEntityDataPacket(this.id, values));
+        to.connection.send(new ClientboundSetEntityDataPacket(this.id, values));
     }
     // Paper end
 
@@ -690,12 +_,12 @@
         return this.id;
     }
 
-    public void remove(Entity.RemovalReason reason) {
+    public void remove(RemovalReason reason) {
         // CraftBukkit start - add Bukkit remove cause
         this.setRemoved(reason, null);
     }
 
-    public void remove(Entity.RemovalReason reason, org.bukkit.event.entity.EntityRemoveEvent.Cause eventCause) {
+    public void remove(RemovalReason reason, EntityRemoveEvent.Cause eventCause) {
         this.setRemoved(reason, eventCause);
         // CraftBukkit end
     }
@@ -703,7 +_,7 @@
     public void onClientRemoval() {
     }
 
-    public void onRemoval(Entity.RemovalReason reason) {
+    public void onRemoval(RemovalReason reason) {
     }
 
     public void setPose(Pose pose) {
@@ -714,7 +_,7 @@
         }
         // Paper start - Don't fire sync event during generation
         if (!this.generation) {
-            this.level.getCraftServer().getPluginManager().callEvent(new org.bukkit.event.entity.EntityPoseChangeEvent(this.getBukkitEntity(), org.bukkit.entity.Pose.values()[pose.ordinal()]));
+            this.level.getCraftServer().getPluginManager().callEvent(new EntityPoseChangeEvent(this.getBukkitEntity(), org.bukkit.entity.Pose.values()[pose.ordinal()]));
         }
         // Paper end - Don't fire sync event during generation
         // CraftBukkit end
@@ -749,7 +_,7 @@
         if (yRot == Float.POSITIVE_INFINITY || yRot == Float.NEGATIVE_INFINITY) {
             if (this instanceof ServerPlayer) {
                 this.level.getCraftServer().getLogger().warning(this.getScoreboardName() + " was caught trying to crash the server with an invalid yaw");
-                ((org.bukkit.craftbukkit.entity.CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite yaw (Hacking?)");
+                ((CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite yaw (Hacking?)");
             }
             yRot = 0;
         }
@@ -762,7 +_,7 @@
         if (xRot == Float.POSITIVE_INFINITY || xRot == Float.NEGATIVE_INFINITY) {
             if (this instanceof ServerPlayer) {
                 this.level.getCraftServer().getLogger().warning(this.getScoreboardName() + " was caught trying to crash the server with an invalid pitch");
-                ((org.bukkit.craftbukkit.entity.CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite pitch (Hacking?)");
+                ((CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite pitch (Hacking?)");
             }
             xRot = 0;
         }
@@ -809,7 +_,7 @@
     public void tick() {
         // Paper start - entity despawn time limit
         if (this.despawnTime >= 0 && this.totalEntityAge >= this.despawnTime) {
-            this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DESPAWN);
+            this.discard(EntityRemoveEvent.Cause.DESPAWN);
             return;
         }
         // Paper end - entity despawn time limit
@@ -828,7 +_,7 @@
     public void baseTick() {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("entityBaseTick");
-        if (firstTick && this instanceof net.minecraft.world.entity.NeutralMob neutralMob) neutralMob.tickInitialPersistentAnger(level); // Paper - Prevent entity loading causing async lookups
+        if (firstTick && this instanceof NeutralMob neutralMob) neutralMob.tickInitialPersistentAnger(level); // Paper - Prevent entity loading causing async lookups
         this.inBlockState = null;
         if (this.isPassenger() && this.getVehicle().isRemoved()) {
             this.stopRiding();
@@ -901,7 +_,7 @@
     public void checkBelowWorld() {
         if (!this.level.getWorld().isVoidDamageEnabled()) return; // Paper - check if void damage is enabled on the world
         // Paper start - Configurable nether ceiling damage
-        if (this.getY() < (this.level.getMinY() + this.level.getWorld().getVoidDamageMinBuildHeightOffset()) || (this.level.getWorld().getEnvironment() == org.bukkit.World.Environment.NETHER // Paper - use configured min build height offset
+        if (this.getY() < (this.level.getMinY() + this.level.getWorld().getVoidDamageMinBuildHeightOffset()) || (this.level.getWorld().getEnvironment() == World.Environment.NETHER // Paper - use configured min build height offset
             && this.level.paperConfig().environment.netherCeilingVoidDamageHeight.test(v -> this.getY() >= v)
             && (!(this instanceof Player player) || !player.getAbilities().invulnerable))) {
             // Paper end - Configurable nether ceiling damage
@@ -934,11 +_,11 @@
     public void lavaHurt() {
         if (!this.fireImmune()) {
             // CraftBukkit start - Fallen in lava TODO: this event spams!
-            if (this instanceof net.minecraft.world.entity.LivingEntity && this.remainingFireTicks <= 0) {
+            if (this instanceof LivingEntity && this.remainingFireTicks <= 0) {
                 // not on fire yet
-                org.bukkit.block.Block damager = (this.lastLavaContact == null) ? null : org.bukkit.craftbukkit.block.CraftBlock.at(this.level, this.lastLavaContact);
+                org.bukkit.block.Block damager = (this.lastLavaContact == null) ? null : CraftBlock.at(this.level, this.lastLavaContact);
                 org.bukkit.entity.Entity damagee = this.getBukkitEntity();
-                org.bukkit.event.entity.EntityCombustEvent combustEvent = new org.bukkit.event.entity.EntityCombustByBlockEvent(damager, damagee, 15);
+                EntityCombustEvent combustEvent = new EntityCombustByBlockEvent(damager, damagee, 15);
                 this.level.getCraftServer().getPluginManager().callEvent(combustEvent);
 
                 if (!combustEvent.isCancelled()) {
@@ -971,7 +_,7 @@
 
     public final void igniteForSeconds(float f, boolean callEvent) {
         if (callEvent) {
-            org.bukkit.event.entity.EntityCombustEvent event = new org.bukkit.event.entity.EntityCombustEvent(this.getBukkitEntity(), f);
+            EntityCombustEvent event = new EntityCombustEvent(this.getBukkitEntity(), f);
             this.level.getCraftServer().getPluginManager().callEvent(event);
 
             if (event.isCancelled()) {
@@ -1003,7 +_,7 @@
     }
 
     protected void onBelowWorld() {
-        this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.OUT_OF_WORLD); // CraftBukkit - add Bukkit remove cause
+        this.discard(EntityRemoveEvent.Cause.OUT_OF_WORLD); // CraftBukkit - add Bukkit remove cause
     }
 
     public boolean isFree(double x, double y, double z) {
@@ -1087,7 +_,7 @@
     public void move(MoverType type, Vec3 movement) {
         final Vec3 originalMovement = movement; // Paper - Expose pre-collision velocity
         // Paper start - detailed watchdog information
-        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread("Cannot move an entity off-main");
+        TickThread.ensureTickThread("Cannot move an entity off-main");
         synchronized (this.posLock) {
             this.moveStartX = this.getX();
             this.moveStartY = this.getY();
@@ -1180,29 +_,29 @@
                 }
 
                 // CraftBukkit start
-                if (this.horizontalCollision && this.getBukkitEntity() instanceof org.bukkit.entity.Vehicle) {
-                    org.bukkit.entity.Vehicle vehicle = (org.bukkit.entity.Vehicle) this.getBukkitEntity();
+                if (this.horizontalCollision && this.getBukkitEntity() instanceof Vehicle) {
+                    Vehicle vehicle = (Vehicle) this.getBukkitEntity();
                     org.bukkit.block.Block bl = this.level.getWorld().getBlockAt(Mth.floor(this.getX()), Mth.floor(this.getY()), Mth.floor(this.getZ()));
 
                     if (movement.x > vec3.x) {
-                        bl = bl.getRelative(org.bukkit.block.BlockFace.EAST);
+                        bl = bl.getRelative(BlockFace.EAST);
                     } else if (movement.x < vec3.x) {
-                        bl = bl.getRelative(org.bukkit.block.BlockFace.WEST);
+                        bl = bl.getRelative(BlockFace.WEST);
                     } else if (movement.z > vec3.z) {
-                        bl = bl.getRelative(org.bukkit.block.BlockFace.SOUTH);
+                        bl = bl.getRelative(BlockFace.SOUTH);
                     } else if (movement.z < vec3.z) {
-                        bl = bl.getRelative(org.bukkit.block.BlockFace.NORTH);
+                        bl = bl.getRelative(BlockFace.NORTH);
                     }
 
                     if (!bl.getType().isAir()) {
-                        org.bukkit.event.vehicle.VehicleBlockCollisionEvent event = new org.bukkit.event.vehicle.VehicleBlockCollisionEvent(vehicle, bl, org.bukkit.craftbukkit.util.CraftVector.toBukkit(originalMovement)); // Paper - Expose pre-collision velocity
+                        VehicleBlockCollisionEvent event = new VehicleBlockCollisionEvent(vehicle, bl, CraftVector.toBukkit(originalMovement)); // Paper - Expose pre-collision velocity
                         this.level.getCraftServer().getPluginManager().callEvent(event);
                     }
                 }
                 // CraftBukkit end
 
                 if (!this.level().isClientSide() || this.isControlledByLocalInstance()) {
-                    Entity.MovementEmission movementEmission = this.getMovementEmission();
+                    MovementEmission movementEmission = this.getMovementEmission();
                     if (movementEmission.emitsAnything() && !this.isPassenger()) {
                         this.applyMovementEmissionAndPlaySound(movementEmission, vec3, onPosLegacy, blockState);
                     }
@@ -1222,7 +_,7 @@
         // Paper end - detailed watchdog information
     }
 
-    private void applyMovementEmissionAndPlaySound(Entity.MovementEmission movementEmission, Vec3 movement, BlockPos pos, BlockState state) {
+    private void applyMovementEmissionAndPlaySound(MovementEmission movementEmission, Vec3 movement, BlockPos pos, BlockState state) {
         float f = 0.6F;
         float f1 = (float)(movement.length() * 0.6F);
         float f2 = (float)(movement.horizontalDistance() * 0.6F);
@@ -1267,8 +_,8 @@
                 blockState.getBlock().stepOn(this.level(), onPosLegacy, blockState, this);
             }
 
-            this.movementThisTick.add(new Entity.Movement(oldPosition, position));
-            List<Entity.Movement> list = List.copyOf(this.movementThisTick);
+            this.movementThisTick.add(new Movement(oldPosition, position));
+            List<Movement> list = List.copyOf(this.movementThisTick);
             this.movementThisTick.clear();
             this.checkInsideBlocks(list, this.blocksInside);
             boolean flag = Iterables.any(this.blocksInside, state -> state.is(BlockTags.FIRE) || state.is(Blocks.LAVA));
@@ -1449,22 +_,22 @@
             // note: xZero & zZero -> collision on x/z == 0 -> no step height calculation
             // this specifically optimises entities standing still
             initialCollisionBox = movement.y < 0.0 ?
-                ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.cutDownwards(currentBox, movement.y) : ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.cutUpwards(currentBox, movement.y);
+                CollisionUtil.cutDownwards(currentBox, movement.y) : CollisionUtil.cutUpwards(currentBox, movement.y);
         } else {
             initialCollisionBox = currentBox.expandTowards(movement);
         }
 
         final List<AABB> entityAABBs = new ArrayList<>();
-        ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getEntityHardCollisions(
+        CollisionUtil.getEntityHardCollisions(
             this.level, (Entity)(Object)this, initialCollisionBox, entityAABBs, 0, null
         );
 
-        ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder(
+        CollisionUtil.getCollisionsForBlocksOrWorldBorder(
             this.level, (Entity)(Object)this, initialCollisionBox, potentialCollisionsVoxel, potentialCollisionsBB,
-            ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER, null
+            CollisionUtil.COLLISION_FLAG_CHECK_BORDER, null
         );
         potentialCollisionsBB.addAll(entityAABBs);
-        final Vec3 collided = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(movement, currentBox, potentialCollisionsVoxel, potentialCollisionsBB);
+        final Vec3 collided = CollisionUtil.performCollisions(movement, currentBox, potentialCollisionsVoxel, potentialCollisionsBB);
 
         final boolean collidedX = collided.x != movement.x;
         final boolean collidedY = collided.y != movement.y;
@@ -1487,13 +_,13 @@
         final List<VoxelShape> stepVoxels = new ArrayList<>();
         final List<AABB> stepAABBs = entityAABBs;
 
-        ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder(
+        CollisionUtil.getCollisionsForBlocksOrWorldBorder(
             this.level, (Entity)(Object)this, stepRetrievalBox, stepVoxels, stepAABBs,
-            ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER, null
+            CollisionUtil.COLLISION_FLAG_CHECK_BORDER, null
         );
 
         for (final float step : calculateStepHeights(collidedYBox, stepVoxels, stepAABBs, (float)stepHeight, (float)collided.y)) {
-            final Vec3 stepResult = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(new Vec3(movement.x, (double)step, movement.z), collidedYBox, stepVoxels, stepAABBs);
+            final Vec3 stepResult = CollisionUtil.performCollisions(new Vec3(movement.x, (double)step, movement.z), collidedYBox, stepVoxels, stepAABBs);
             if (stepResult.horizontalDistanceSqr() > collided.horizontalDistanceSqr()) {
                 return stepResult.add(0.0, collidedYBox.minY - currentBox.minY, 0.0);
             }
@@ -1613,14 +_,14 @@
     // CraftBukkit end
 
     public void recordMovementThroughBlocks(Vec3 oldPosition, Vec3 position) {
-        this.movementThisTick.add(new Entity.Movement(oldPosition, position));
+        this.movementThisTick.add(new Movement(oldPosition, position));
     }
 
-    private void checkInsideBlocks(List<Entity.Movement> movements, Set<BlockState> blocksInside) {
+    private void checkInsideBlocks(List<Movement> movements, Set<BlockState> blocksInside) {
         if (this.isAffectedByBlocks()) {
             LongSet set = this.visitedBlocks;
 
-            for (Entity.Movement movement : movements) {
+            for (Movement movement : movements) {
                 Vec3 vec3 = movement.from();
                 Vec3 vec31 = movement.to();
                 AABB aabb = this.makeBoundingBox(vec31).deflate(1.0E-5F);
@@ -1789,8 +_,8 @@
         }
     }
 
-    protected Entity.MovementEmission getMovementEmission() {
-        return Entity.MovementEmission.ALL;
+    protected MovementEmission getMovementEmission() {
+        return MovementEmission.ALL;
     }
 
     public boolean dampensVibrations() {
@@ -2196,9 +_,9 @@
     }
 
     public void push(double x, double y, double z, @Nullable Entity pushingEntity) {
-        org.bukkit.util.Vector delta = new org.bukkit.util.Vector(x, y, z);
+        Vector delta = new Vector(x, y, z);
         if (pushingEntity != null) {
-            io.papermc.paper.event.entity.EntityPushedByEntityAttackEvent event = new io.papermc.paper.event.entity.EntityPushedByEntityAttackEvent(this.getBukkitEntity(), io.papermc.paper.event.entity.EntityKnockbackEvent.Cause.PUSH, pushingEntity.getBukkitEntity(), delta);
+            EntityPushedByEntityAttackEvent event = new EntityPushedByEntityAttackEvent(this.getBukkitEntity(), EntityKnockbackEvent.Cause.PUSH, pushingEntity.getBukkitEntity(), delta);
             if (!event.callEvent()) {
                 return;
             }
@@ -2610,7 +_,7 @@
             }
             // CraftBukkit start
             // Spigot start
-            if (this instanceof net.minecraft.world.entity.LivingEntity) {
+            if (this instanceof LivingEntity) {
                 this.totalEntityAge = compound.getInt("Spigot.ticksLived"); // Paper
             }
             // Spigot end
@@ -2633,7 +_,7 @@
             // CraftBukkit end
 
             // Paper start
-            ListTag originTag = compound.getList("Paper.Origin", net.minecraft.nbt.Tag.TAG_DOUBLE);
+            ListTag originTag = compound.getList("Paper.Origin", Tag.TAG_DOUBLE);
             if (!originTag.isEmpty()) {
                 UUID originWorld = null;
                 if (compound.contains("Paper.OriginWorld")) {
@@ -2642,7 +_,7 @@
                     originWorld = this.level.getWorld().getUID();
                 }
                 this.originWorld = originWorld;
-                origin = new org.bukkit.util.Vector(originTag.getDouble(0), originTag.getDouble(1), originTag.getDouble(2));
+                origin = new Vector(originTag.getDouble(0), originTag.getDouble(1), originTag.getDouble(2));
             }
 
             spawnedViaMobSpawner = compound.getBoolean("Paper.FromMobSpawner"); // Restore entity's from mob spawner status
@@ -2650,22 +_,22 @@
             if (compound.contains("Paper.SpawnReason")) {
                 String spawnReasonName = compound.getString("Paper.SpawnReason");
                 try {
-                    spawnReason = org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.valueOf(spawnReasonName);
+                    spawnReason = CreatureSpawnEvent.SpawnReason.valueOf(spawnReasonName);
                 } catch (Exception ignored) {
                     LOGGER.error("Unknown SpawnReason " + spawnReasonName + " for " + this);
                 }
             }
             if (spawnReason == null) {
                 if (spawnedViaMobSpawner) {
-                    spawnReason = org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.SPAWNER;
-                } else if (this instanceof Mob && (this instanceof net.minecraft.world.entity.animal.Animal || this instanceof net.minecraft.world.entity.animal.AbstractFish) && !((Mob) this).removeWhenFarAway(0.0)) {
+                    spawnReason = CreatureSpawnEvent.SpawnReason.SPAWNER;
+                } else if (this instanceof Mob && (this instanceof Animal || this instanceof AbstractFish) && !((Mob) this).removeWhenFarAway(0.0)) {
                     if (!compound.getBoolean("PersistenceRequired")) {
-                        spawnReason = org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.NATURAL;
+                        spawnReason = CreatureSpawnEvent.SpawnReason.NATURAL;
                     }
                 }
             }
             if (spawnReason == null) {
-                spawnReason = org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT;
+                spawnReason = CreatureSpawnEvent.SpawnReason.DEFAULT;
             }
             if (compound.contains("Paper.FreezeLock")) {
                 freezeLocked = compound.getBoolean("Paper.FreezeLock");
@@ -2745,29 +_,29 @@
         // Paper start - Restore vanilla drops behavior
         return this.spawnAtLocation(level, stack, yOffset, null);
     }
-    public record DefaultDrop(Item item, org.bukkit.inventory.ItemStack stack, @Nullable java.util.function.Consumer<ItemStack> dropConsumer) {
-        public DefaultDrop(final ItemStack stack, final java.util.function.Consumer<ItemStack> dropConsumer) {
-            this(stack.getItem(), org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(stack), dropConsumer);
+    public record DefaultDrop(Item item, org.bukkit.inventory.ItemStack stack, @Nullable Consumer<ItemStack> dropConsumer) {
+        public DefaultDrop(final ItemStack stack, final Consumer<ItemStack> dropConsumer) {
+            this(stack.getItem(), CraftItemStack.asCraftMirror(stack), dropConsumer);
         }
 
-        public void runConsumer(final java.util.function.Consumer<org.bukkit.inventory.ItemStack> fallback) {
-            if (this.dropConsumer == null || org.bukkit.craftbukkit.inventory.CraftItemType.bukkitToMinecraft(this.stack.getType()) != this.item) {
+        public void runConsumer(final Consumer<org.bukkit.inventory.ItemStack> fallback) {
+            if (this.dropConsumer == null || CraftItemType.bukkitToMinecraft(this.stack.getType()) != this.item) {
                 fallback.accept(this.stack);
             } else {
-                this.dropConsumer.accept(org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(this.stack));
+                this.dropConsumer.accept(CraftItemStack.asNMSCopy(this.stack));
             }
         }
     }
     @Nullable
-    public ItemEntity spawnAtLocation(ServerLevel level, ItemStack stack, float yOffset, @Nullable java.util.function.Consumer<? super ItemEntity> delayedAddConsumer) {
+    public ItemEntity spawnAtLocation(ServerLevel level, ItemStack stack, float yOffset, @Nullable Consumer<? super ItemEntity> delayedAddConsumer) {
         // Paper end - Restore vanilla drops behavior
         if (stack.isEmpty()) {
             return null;
         } else {
             // CraftBukkit start - Capture drops for death event
-            if (this instanceof net.minecraft.world.entity.LivingEntity && !this.forceDrops) {
+            if (this instanceof LivingEntity && !this.forceDrops) {
                 // Paper start - Restore vanilla drops behavior
-                ((net.minecraft.world.entity.LivingEntity) this).drops.add(new net.minecraft.world.entity.Entity.DefaultDrop(stack, itemStack -> {
+                ((LivingEntity) this).drops.add(new DefaultDrop(stack, itemStack -> {
                     ItemEntity itemEntity = new ItemEntity(this.level, this.getX(), this.getY() + (double) yOffset, this.getZ(), itemStack); // stack is copied before consumer
                     itemEntity.setDefaultPickUpDelay();
                     this.level.addFreshEntity(itemEntity);
@@ -2791,8 +_,8 @@
         {
             // Paper end - Call EntityDropItemEvent
             // CraftBukkit start
-            org.bukkit.event.entity.EntityDropItemEvent event = new org.bukkit.event.entity.EntityDropItemEvent(this.getBukkitEntity(), (org.bukkit.entity.Item) itemEntity.getBukkitEntity());
-            org.bukkit.Bukkit.getPluginManager().callEvent(event);
+            EntityDropItemEvent event = new EntityDropItemEvent(this.getBukkitEntity(), (org.bukkit.entity.Item) itemEntity.getBukkitEntity());
+            Bukkit.getPluginManager().callEvent(event);
             if (event.isCancelled()) {
                 return null;
             }
@@ -2816,7 +_,7 @@
         final AABB boundingBox = AABB.ofSize(this.getEyePosition(), reducedWith, 1.0E-6D, reducedWith);
         final Level world = this.level;
 
-        if (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.isEmpty(boundingBox)) {
+        if (CollisionUtil.isEmpty(boundingBox)) {
             return false;
         }
 
@@ -2836,26 +_,26 @@
         final int maxChunkY = maxBlockY >> 4;
         final int maxChunkZ = maxBlockZ >> 4;
 
-        final int minSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinSection(world);
-        final net.minecraft.world.level.chunk.ChunkSource chunkSource = world.getChunkSource();
+        final int minSection = WorldUtil.getMinSection(world);
+        final ChunkSource chunkSource = world.getChunkSource();
         final BlockPos.MutableBlockPos mutablePos = new BlockPos.MutableBlockPos();
 
         for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
             for (int currChunkX = minChunkX; currChunkX <= maxChunkX; ++currChunkX) {
-                final net.minecraft.world.level.chunk.LevelChunkSection[] sections = chunkSource.getChunk(currChunkX, currChunkZ, net.minecraft.world.level.chunk.status.ChunkStatus.FULL, true).getSections();
+                final LevelChunkSection[] sections = chunkSource.getChunk(currChunkX, currChunkZ, ChunkStatus.FULL, true).getSections();
 
                 for (int currChunkY = minChunkY; currChunkY <= maxChunkY; ++currChunkY) {
                     final int sectionIdx = currChunkY - minSection;
                     if (sectionIdx < 0 || sectionIdx >= sections.length) {
                         continue;
                     }
-                    final net.minecraft.world.level.chunk.LevelChunkSection section = sections[sectionIdx];
+                    final LevelChunkSection section = sections[sectionIdx];
                     if (section.hasOnlyAir()) {
                         // empty
                         continue;
                     }
 
-                    final net.minecraft.world.level.chunk.PalettedContainer<net.minecraft.world.level.block.state.BlockState> blocks = section.states;
+                    final PalettedContainer<BlockState> blocks = section.states;
 
                     final int minXIterate = currChunkX == minChunkX ? (minBlockX & 15) : 0;
                     final int maxXIterate = currChunkX == maxChunkX ? (maxBlockX & 15) : 15;
@@ -2876,7 +_,7 @@
 
                                 final BlockState blockState = blocks.get((currX) | (currZ << 4) | ((currY) << 8));
 
-                                if (((ca.spottedleaf.moonrise.patches.collisions.block.CollisionBlockState)blockState).moonrise$emptyCollisionShape()
+                                if (((CollisionBlockState)blockState).moonrise$emptyCollisionShape()
                                     || !blockState.isSuffocating(world, mutablePos)) {
                                     continue;
                                 }
@@ -2890,15 +_,15 @@
 
                                 final AABB toCollide = boundingBox.move(-(double)blockX, -(double)blockY, -(double)blockZ);
 
-                                final AABB singleAABB = ((ca.spottedleaf.moonrise.patches.collisions.shape.CollisionVoxelShape)collisionShape).moonrise$getSingleAABBRepresentation();
+                                final AABB singleAABB = ((CollisionVoxelShape)collisionShape).moonrise$getSingleAABBRepresentation();
                                 if (singleAABB != null) {
-                                    if (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.voxelShapeIntersect(singleAABB, toCollide)) {
+                                    if (CollisionUtil.voxelShapeIntersect(singleAABB, toCollide)) {
                                         return true;
                                     }
                                     continue;
                                 }
 
-                                if (ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.voxelShapeIntersectNoEmpty(collisionShape, toCollide)) {
+                                if (CollisionUtil.voxelShapeIntersectNoEmpty(collisionShape, toCollide)) {
                                     return true;
                                 }
                                 continue;
@@ -2919,10 +_,10 @@
                 if (!this.level().isClientSide()) {
                     // CraftBukkit start - fire PlayerUnleashEntityEvent
                     // Paper start - Expand EntityUnleashEvent
-                    org.bukkit.event.player.PlayerUnleashEntityEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerUnleashEntityEvent(this, player, hand, !player.hasInfiniteMaterials());
+                    PlayerUnleashEntityEvent event = CraftEventFactory.callPlayerUnleashEntityEvent(this, player, hand, !player.hasInfiniteMaterials());
                     if (event.isCancelled()) {
                         // Paper end - Expand EntityUnleashEvent
-                        ((ServerPlayer) player).connection.send(new net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket(this, leashable.getLeashHolder()));
+                        ((ServerPlayer) player).connection.send(new ClientboundSetEntityLinkPacket(this, leashable.getLeashHolder()));
                         return InteractionResult.PASS;
                     }
                     // CraftBukkit end
@@ -2942,8 +_,8 @@
             if (itemInHand.is(Items.LEAD) && leashable.canHaveALeashAttachedToIt()) {
                 if (!this.level().isClientSide()) {
                     // CraftBukkit start - fire PlayerLeashEntityEvent
-                    if (org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerLeashEntityEvent(this, player, player, hand).isCancelled()) {
-                        ((ServerPlayer) player).connection.send(new net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket(this, leashable.getLeashHolder()));
+                    if (CraftEventFactory.callPlayerLeashEntityEvent(this, player, player, hand).isCancelled()) {
+                        ((ServerPlayer) player).connection.send(new ClientboundSetEntityLinkPacket(this, leashable.getLeashHolder()));
                         player.containerMenu.sendAllDataToRemote(); // Paper - Fix inventory desync
                         return InteractionResult.PASS;
                     }
@@ -2981,7 +_,7 @@
         }
     }
 
-    protected void positionRider(Entity passenger, Entity.MoveFunction callback) {
+    protected void positionRider(Entity passenger, MoveFunction callback) {
         Vec3 passengerRidingPosition = this.getPassengerRidingPosition(passenger);
         Vec3 vehicleAttachmentPoint = passenger.getVehicleAttachmentPoint(this);
         callback.accept(
@@ -3036,21 +_,21 @@
 
             if (force || this.canRide(vehicle) && vehicle.canAddPassenger(this)) {
                 // CraftBukkit start
-                if (vehicle.getBukkitEntity() instanceof org.bukkit.entity.Vehicle && this.getBukkitEntity() instanceof org.bukkit.entity.LivingEntity) {
-                    org.bukkit.event.vehicle.VehicleEnterEvent event = new org.bukkit.event.vehicle.VehicleEnterEvent((org.bukkit.entity.Vehicle) vehicle.getBukkitEntity(), this.getBukkitEntity());
+                if (vehicle.getBukkitEntity() instanceof Vehicle && this.getBukkitEntity() instanceof org.bukkit.entity.LivingEntity) {
+                    VehicleEnterEvent event = new VehicleEnterEvent((Vehicle) vehicle.getBukkitEntity(), this.getBukkitEntity());
                     // Suppress during worldgen
                     if (this.valid) {
-                        org.bukkit.Bukkit.getPluginManager().callEvent(event);
+                        Bukkit.getPluginManager().callEvent(event);
                     }
                     if (event.isCancelled()) {
                         return false;
                     }
                 }
 
-                org.bukkit.event.entity.EntityMountEvent event = new org.bukkit.event.entity.EntityMountEvent(this.getBukkitEntity(), vehicle.getBukkitEntity());
+                EntityMountEvent event = new EntityMountEvent(this.getBukkitEntity(), vehicle.getBukkitEntity());
                 // Suppress during worldgen
                 if (this.valid) {
-                    org.bukkit.Bukkit.getPluginManager().callEvent(event);
+                    Bukkit.getPluginManager().callEvent(event);
                 }
                 if (event.isCancelled()) {
                     return false;
@@ -3137,28 +_,28 @@
             throw new IllegalStateException("Use x.stopRiding(y), not y.removePassenger(x)");
         } else {
             // CraftBukkit start
-            org.bukkit.craftbukkit.entity.CraftEntity craft = (org.bukkit.craftbukkit.entity.CraftEntity) passenger.getBukkitEntity().getVehicle();
+            CraftEntity craft = (CraftEntity) passenger.getBukkitEntity().getVehicle();
             Entity orig = craft == null ? null : craft.getHandle();
-            if (this.getBukkitEntity() instanceof org.bukkit.entity.Vehicle && passenger.getBukkitEntity() instanceof org.bukkit.entity.LivingEntity) {
-                org.bukkit.event.vehicle.VehicleExitEvent event = new org.bukkit.event.vehicle.VehicleExitEvent(
-                        (org.bukkit.entity.Vehicle) this.getBukkitEntity(),
+            if (this.getBukkitEntity() instanceof Vehicle && passenger.getBukkitEntity() instanceof org.bukkit.entity.LivingEntity) {
+                VehicleExitEvent event = new VehicleExitEvent(
+                        (Vehicle) this.getBukkitEntity(),
                         (org.bukkit.entity.LivingEntity) passenger.getBukkitEntity(), !suppressCancellation // Paper - Force entity dismount during teleportation
                 );
                 // Suppress during worldgen
                 if (this.valid) {
-                    org.bukkit.Bukkit.getPluginManager().callEvent(event);
+                    Bukkit.getPluginManager().callEvent(event);
                 }
-                org.bukkit.craftbukkit.entity.CraftEntity craftn = (org.bukkit.craftbukkit.entity.CraftEntity) passenger.getBukkitEntity().getVehicle();
+                CraftEntity craftn = (CraftEntity) passenger.getBukkitEntity().getVehicle();
                 Entity n = craftn == null ? null : craftn.getHandle();
                 if (event.isCancelled() || n != orig) {
                     return false;
                 }
             }
 
-            org.bukkit.event.entity.EntityDismountEvent event = new org.bukkit.event.entity.EntityDismountEvent(passenger.getBukkitEntity(), this.getBukkitEntity(), !suppressCancellation); // Paper - Force entity dismount during teleportation
+            EntityDismountEvent event = new EntityDismountEvent(passenger.getBukkitEntity(), this.getBukkitEntity(), !suppressCancellation); // Paper - Force entity dismount during teleportation
             // Suppress during worldgen
             if (this.valid) {
-                org.bukkit.Bukkit.getPluginManager().callEvent(event);
+                Bukkit.getPluginManager().callEvent(event);
             }
             if (event.isCancelled()) {
                 return false;
@@ -3260,19 +_,21 @@
             this.processPortalCooldown();
             if (this.portalProcess != null) {
                 if (this.portalProcess.processPortalTeleportation(serverLevel, this, this.canUsePortal(false))) {
-                    ProfilerFiller profilerFiller = Profiler.get();
-                    profilerFiller.push("portal");
+                    // ProfilerFiller profilerFiller = Profiler.get(); // Octopus
+                    // profilerFiller.push("portal"); // Octopus
                     this.setPortalCooldown();
+                    ((ServerLevel) this.level).worldTaskQueueInstance.submitCallbackTask(() -> { // Octopus
                     TeleportTransition portalDestination = this.portalProcess.getPortalDestination(serverLevel, this);
                     if (portalDestination != null) {
                         ServerLevel level = portalDestination.newLevel();
                         if (this instanceof ServerPlayer // CraftBukkit - always call event for players
                             || (level != null && (level.dimension() == serverLevel.dimension() || this.canTeleport(serverLevel, level)))) { // CraftBukkit
-                            this.teleport(portalDestination);
+                            this.teleport(portalDestination, null);
                         }
                     }
+                    }); // Octopus
 
-                    profilerFiller.pop();
+                    // profilerFiller.pop(); // Octopus
                 } else if (this.portalProcess.hasExpired()) {
                     this.portalProcess = null;
                 }
@@ -3348,7 +_,7 @@
     }
 
     public boolean isCrouching() {
-        return this.hasPose(net.minecraft.world.entity.Pose.CROUCHING);
+        return this.hasPose(Pose.CROUCHING);
     }
 
     public boolean isSprinting() {
@@ -3364,7 +_,7 @@
     }
 
     public boolean isVisuallySwimming() {
-        return this.hasPose(net.minecraft.world.entity.Pose.SWIMMING);
+        return this.hasPose(Pose.SWIMMING);
     }
 
     public boolean isVisuallyCrawling() {
@@ -3373,8 +_,8 @@
 
     public void setSwimming(boolean swimming) {
         // CraftBukkit start
-        if (this.valid && this.isSwimming() != swimming && this instanceof net.minecraft.world.entity.LivingEntity) {
-            if (org.bukkit.craftbukkit.event.CraftEventFactory.callToggleSwimEvent((net.minecraft.world.entity.LivingEntity) this, swimming).isCancelled()) {
+        if (this.valid && this.isSwimming() != swimming && this instanceof LivingEntity) {
+            if (CraftEventFactory.callToggleSwimEvent((LivingEntity) this, swimming).isCancelled()) {
                 return;
             }
         }
@@ -3464,7 +_,7 @@
 
     public void setAirSupply(int air) {
         // CraftBukkit start
-        org.bukkit.event.entity.EntityAirChangeEvent event = new org.bukkit.event.entity.EntityAirChangeEvent(this.getBukkitEntity(), air);
+        EntityAirChangeEvent event = new EntityAirChangeEvent(this.getBukkitEntity(), air);
         // Suppress during worldgen
         if (this.valid) {
             event.getEntity().getServer().getPluginManager().callEvent(event);
@@ -3503,11 +_,11 @@
         // CraftBukkit start
         final org.bukkit.entity.Entity thisBukkitEntity = this.getBukkitEntity();
         final org.bukkit.entity.Entity stormBukkitEntity = lightning.getBukkitEntity();
-        final org.bukkit.plugin.PluginManager pluginManager = org.bukkit.Bukkit.getPluginManager();
+        final PluginManager pluginManager = Bukkit.getPluginManager();
         // CraftBukkit end
         if (this.remainingFireTicks == 0) {
             // CraftBukkit start - Call a combust event when lightning strikes
-            org.bukkit.event.entity.EntityCombustByEntityEvent entityCombustEvent = new org.bukkit.event.entity.EntityCombustByEntityEvent(stormBukkitEntity, thisBukkitEntity, 8.0F);
+            EntityCombustByEntityEvent entityCombustEvent = new EntityCombustByEntityEvent(stormBukkitEntity, thisBukkitEntity, 8.0F);
             pluginManager.callEvent(entityCombustEvent);
             if (!entityCombustEvent.isCancelled()) {
                 this.igniteForSeconds(entityCombustEvent.getDuration(), false);
@@ -3520,8 +_,8 @@
         }
 
         // CraftBukkit start
-        if (thisBukkitEntity instanceof org.bukkit.entity.Hanging) {
-            org.bukkit.event.hanging.HangingBreakByEntityEvent hangingEvent = new org.bukkit.event.hanging.HangingBreakByEntityEvent((org.bukkit.entity.Hanging) thisBukkitEntity, stormBukkitEntity);
+        if (thisBukkitEntity instanceof Hanging) {
+            HangingBreakByEntityEvent hangingEvent = new HangingBreakByEntityEvent((Hanging) thisBukkitEntity, stormBukkitEntity);
             pluginManager.callEvent(hangingEvent);
 
             if (hangingEvent.isCancelled()) {
@@ -3710,7 +_,7 @@
 
     public void restoreFrom(Entity entity) {
         // Paper start - Forward CraftEntity in teleport command
-        org.bukkit.craftbukkit.entity.CraftEntity bukkitEntity = entity.bukkitEntity;
+        CraftEntity bukkitEntity = entity.bukkitEntity;
         if (bukkitEntity != null) {
             bukkitEntity.setHandle(this);
             this.bukkitEntity = bukkitEntity;
@@ -3724,10 +_,11 @@
     }
 
     @Nullable
-    public Entity teleport(TeleportTransition teleportTransition) {
+    public Entity teleport(TeleportTransition teleportTransition, Consumer<Entity> callback) { // Octopus
         // Paper start - Fix item duplication and teleport issues
         if ((!this.isAlive() || !this.valid) && (teleportTransition.newLevel() != this.level)) {
             LOGGER.warn("Illegal Entity Teleport " + this + " to " + teleportTransition.newLevel() + ":" + teleportTransition.position(), new Throwable());
+            if (callback != null) callback.accept(null); // Octopus
             return null;
         }
         // Paper end - Fix item duplication and teleport issues
@@ -3735,42 +_,44 @@
             // CraftBukkit start
             PositionMoveRotation absolutePosition = PositionMoveRotation.calculateAbsolute(PositionMoveRotation.of(this), PositionMoveRotation.of(teleportTransition), teleportTransition.relatives());
             Vec3 velocity = absolutePosition.deltaMovement(); // Paper
-            org.bukkit.Location to = org.bukkit.craftbukkit.util.CraftLocation.toBukkit(absolutePosition.position(), teleportTransition.newLevel().getWorld(), absolutePosition.yRot(), absolutePosition.xRot());
+            Location to = CraftLocation.toBukkit(absolutePosition.position(), teleportTransition.newLevel().getWorld(), absolutePosition.yRot(), absolutePosition.xRot());
             // Paper start - gateway-specific teleport event
-            final org.bukkit.event.entity.EntityTeleportEvent teleEvent;
-            if (this.portalProcess != null && this.portalProcess.isSamePortal(((net.minecraft.world.level.block.EndGatewayBlock) net.minecraft.world.level.block.Blocks.END_GATEWAY)) && this.level.getBlockEntity(this.portalProcess.getEntryPosition()) instanceof net.minecraft.world.level.block.entity.TheEndGatewayBlockEntity theEndGatewayBlockEntity) {
-                teleEvent = new com.destroystokyo.paper.event.entity.EntityTeleportEndGatewayEvent(this.getBukkitEntity(), this.getBukkitEntity().getLocation(), to, new org.bukkit.craftbukkit.block.CraftEndGateway(to.getWorld(), theEndGatewayBlockEntity));
+            final EntityTeleportEvent teleEvent;
+            if (this.portalProcess != null && this.portalProcess.isSamePortal(((EndGatewayBlock) Blocks.END_GATEWAY)) && this.level.getBlockEntity(this.portalProcess.getEntryPosition()) instanceof TheEndGatewayBlockEntity theEndGatewayBlockEntity) {
+                teleEvent = new EntityTeleportEndGatewayEvent(this.getBukkitEntity(), this.getBukkitEntity().getLocation(), to, new CraftEndGateway(to.getWorld(), theEndGatewayBlockEntity));
                 teleEvent.callEvent();
             } else {
-                teleEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTeleportEvent(this, to);
+                teleEvent = CraftEventFactory.callEntityTeleportEvent(this, to);
             }
             // Paper end - gateway-specific teleport event
             if (teleEvent.isCancelled() || teleEvent.getTo() == null) {
+                if (callback != null) callback.accept(null); // Octopus
                 return null;
             }
             if (!to.equals(teleEvent.getTo())) {
                 to = teleEvent.getTo();
-                teleportTransition = new TeleportTransition(((org.bukkit.craftbukkit.CraftWorld) to.getWorld()).getHandle(), org.bukkit.craftbukkit.util.CraftLocation.toVec3D(to), Vec3.ZERO, to.getYaw(), to.getPitch(), teleportTransition.missingRespawnBlock(), teleportTransition.asPassenger(), Set.of(), teleportTransition.postTeleportTransition(), teleportTransition.cause());
+                teleportTransition = new TeleportTransition(((CraftWorld) to.getWorld()).getHandle(), CraftLocation.toVec3D(to), Vec3.ZERO, to.getYaw(), to.getPitch(), teleportTransition.missingRespawnBlock(), teleportTransition.asPassenger(), Set.of(), teleportTransition.postTeleportTransition(), teleportTransition.cause());
                 // Paper start - Call EntityPortalExitEvent
                 velocity = Vec3.ZERO;
             }
             if (this.portalProcess != null) { // if in a portal
-                org.bukkit.craftbukkit.entity.CraftEntity bukkitEntity = this.getBukkitEntity();
-                org.bukkit.event.entity.EntityPortalExitEvent event = new org.bukkit.event.entity.EntityPortalExitEvent(
+                CraftEntity bukkitEntity = this.getBukkitEntity();
+                EntityPortalExitEvent event = new EntityPortalExitEvent(
                     bukkitEntity,
                     bukkitEntity.getLocation(), to.clone(),
-                    bukkitEntity.getVelocity(), org.bukkit.craftbukkit.util.CraftVector.toBukkit(velocity)
+                    bukkitEntity.getVelocity(), CraftVector.toBukkit(velocity)
                 );
                 event.callEvent();
 
                 // Only change the target if actually needed, since we reset relative flags
                 if (!event.isCancelled() && event.getTo() != null && (!event.getTo().equals(event.getFrom()) || !event.getAfter().equals(event.getBefore()))) {
                     to = event.getTo().clone();
-                    velocity = org.bukkit.craftbukkit.util.CraftVector.toNMS(event.getAfter());
-                    teleportTransition = new TeleportTransition(((org.bukkit.craftbukkit.CraftWorld) to.getWorld()).getHandle(), org.bukkit.craftbukkit.util.CraftLocation.toVec3D(to), velocity, to.getYaw(), to.getPitch(), teleportTransition.missingRespawnBlock(), teleportTransition.asPassenger(), Set.of(), teleportTransition.postTeleportTransition(), teleportTransition.cause());
+                    velocity = CraftVector.toNMS(event.getAfter());
+                    teleportTransition = new TeleportTransition(((CraftWorld) to.getWorld()).getHandle(), CraftLocation.toVec3D(to), velocity, to.getYaw(), to.getPitch(), teleportTransition.missingRespawnBlock(), teleportTransition.asPassenger(), Set.of(), teleportTransition.postTeleportTransition(), teleportTransition.cause());
                 }
             }
             if (this.isRemoved()) {
+                if (callback != null) callback.accept(null); // Octopus
                 return null;
             }
             // Paper end - Call EntityPortalExitEvent
@@ -3781,15 +_,15 @@
                 this.stopRiding();
             }
 
-            return flag ? this.teleportCrossDimension(level, teleportTransition) : this.teleportSameDimension(serverLevel, teleportTransition);
+            return flag ? this.teleportCrossDimension(level, teleportTransition, callback) : this.teleportSameDimension(serverLevel, teleportTransition, callback); // Octopus
         } else {
             return null;
         }
     }
 
-    private Entity teleportSameDimension(ServerLevel level, TeleportTransition teleportTransition) {
+    private Entity teleportSameDimension(ServerLevel level, TeleportTransition teleportTransition, Consumer<Entity> callback) { // Octopus
         for (Entity entity : this.getPassengers()) {
-            entity.teleport(this.calculatePassengerTransition(teleportTransition, entity));
+            entity.teleport(this.calculatePassengerTransition(teleportTransition, entity), null); // Octopus
         }
 
         ProfilerFiller profilerFiller = Profiler.get();
@@ -3801,26 +_,27 @@
 
         teleportTransition.postTeleportTransition().onTransition(this);
         profilerFiller.pop();
+        if (callback != null) callback.accept(this); // Octopus
         return this;
     }
 
-    private Entity teleportCrossDimension(ServerLevel level, TeleportTransition teleportTransition) {
+    private Entity teleportCrossDimension(ServerLevel level, TeleportTransition teleportTransition, Consumer<Entity> callback) {
         List<Entity> passengers = this.getPassengers();
         List<Entity> list = new ArrayList<>(passengers.size());
         this.ejectPassengers();
 
         for (Entity entity : passengers) {
-            Entity entity1 = entity.teleport(this.calculatePassengerTransition(teleportTransition, entity));
+            Entity entity1 = entity.teleport(this.calculatePassengerTransition(teleportTransition, entity), null); // Octopus
             if (entity1 != null) {
                 list.add(entity1);
             }
         }
 
         ProfilerFiller profilerFiller = Profiler.get();
-        profilerFiller.push("teleportCrossDimension");
+        // profilerFiller.push("teleportCrossDimension"); // Octopus
         Entity entityx = this.getType().create(level, EntitySpawnReason.DIMENSION_TRAVEL);
         if (entityx == null) {
-            profilerFiller.pop();
+            // profilerFiller.pop(); // Octopus
             return null;
         } else {
             // Paper start - Fix item duplication and teleport issues
@@ -3830,6 +_,9 @@
             // Paper end - Fix item duplication and teleport issues
             entityx.restoreFrom(this);
             this.removeAfterChangingDimensions();
+            // Octopus start
+            // Submit callback so that we would run the task eventually
+            java.lang.Runnable scheduledAdd = () -> {
             // CraftBukkit start - Forward the CraftEntity to the new entity
             //this.getBukkitEntity().setHandle(entity);
             //entity.bukkitEntity = this.getBukkitEntity(); // Paper - forward CraftEntity in teleport command; moved to Entity#restoreFrom
@@ -3843,7 +_,15 @@
 
             level.resetEmptyTime();
             teleportTransition.postTeleportTransition().onTransition(entityx);
-            profilerFiller.pop();
+            if (callback != null) callback.accept(entityx); // Octopus
+            };
+            if (level.worldTaskQueueInstance.isHeldByAnyThread() && level.worldTaskQueueInstance.isFullyHeldByCurrentThread()) {
+                scheduledAdd.run();
+            }else {
+                level.worldTaskQueueInstance.submitCallbackTask(scheduledAdd);
+            }
+            // profilerFiller.pop();
+            // Octopus end
             return entityx;
         }
     }
@@ -3909,10 +_,10 @@
     }
 
     protected void removeAfterChangingDimensions() {
-        this.setRemoved(Entity.RemovalReason.CHANGED_DIMENSION, null); // CraftBukkit - add Bukkit remove cause
+        this.setRemoved(RemovalReason.CHANGED_DIMENSION, null); // CraftBukkit - add Bukkit remove cause
         if (this instanceof Leashable leashable && leashable.isLeashed()) { // Paper - only call if it is leashed
             // Paper start - Expand EntityUnleashEvent
-            final org.bukkit.event.entity.EntityUnleashEvent event = new org.bukkit.event.entity.EntityUnleashEvent(this.getBukkitEntity(), org.bukkit.event.entity.EntityUnleashEvent.UnleashReason.UNKNOWN, false); // CraftBukkit
+            final EntityUnleashEvent event = new EntityUnleashEvent(this.getBukkitEntity(), EntityUnleashEvent.UnleashReason.UNKNOWN, false); // CraftBukkit
             event.callEvent();
             if (!event.isDropLeash()) {
                 leashable.removeLeash();
@@ -3928,24 +_,24 @@
     }
 
     // CraftBukkit start
-    public org.bukkit.craftbukkit.event.CraftPortalEvent callPortalEvent(Entity entity, org.bukkit.Location exit, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause, int searchRadius, int creationRadius) {
+    public CraftPortalEvent callPortalEvent(Entity entity, Location exit, PlayerTeleportEvent.TeleportCause cause, int searchRadius, int creationRadius) {
         org.bukkit.entity.Entity bukkitEntity = entity.getBukkitEntity();
-        org.bukkit.Location enter = bukkitEntity.getLocation();
+        Location enter = bukkitEntity.getLocation();
 
         // Paper start
-        final org.bukkit.PortalType portalType = switch (cause) {
-            case END_PORTAL -> org.bukkit.PortalType.ENDER;
-            case NETHER_PORTAL -> org.bukkit.PortalType.NETHER;
-            case END_GATEWAY -> org.bukkit.PortalType.END_GATEWAY; // not actually used yet
-            default -> org.bukkit.PortalType.CUSTOM;
+        final PortalType portalType = switch (cause) {
+            case END_PORTAL -> PortalType.ENDER;
+            case NETHER_PORTAL -> PortalType.NETHER;
+            case END_GATEWAY -> PortalType.END_GATEWAY; // not actually used yet
+            default -> PortalType.CUSTOM;
         };
-        org.bukkit.event.entity.EntityPortalEvent event = new org.bukkit.event.entity.EntityPortalEvent(bukkitEntity, enter, exit, searchRadius, true, creationRadius, portalType);
+        EntityPortalEvent event = new EntityPortalEvent(bukkitEntity, enter, exit, searchRadius, true, creationRadius, portalType);
         // Paper end
         event.getEntity().getServer().getPluginManager().callEvent(event);
         if (event.isCancelled() || event.getTo() == null || event.getTo().getWorld() == null || !entity.isAlive()) {
             return null;
         }
-        return new org.bukkit.craftbukkit.event.CraftPortalEvent(event);
+        return new CraftPortalEvent(event);
     }
     // CraftBukkit end
 
@@ -4063,13 +_,13 @@
     }
 
     // CraftBukkit start
-    public final boolean teleportTo(ServerLevel level, double x, double y, double z, Set<Relative> relativeMovements, float yaw, float pitch, boolean setCamera) {
-        return this.teleportTo(level, x, y, z, relativeMovements, yaw, pitch, setCamera, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.UNKNOWN);
+    public final boolean teleportTo(ServerLevel level, double x, double y, double z, Set<Relative> relativeMovements, float yaw, float pitch, boolean setCamera, Consumer<Entity> callback) { // Octopus
+        return this.teleportTo(level, x, y, z, relativeMovements, yaw, pitch, setCamera, PlayerTeleportEvent.TeleportCause.UNKNOWN, callback); // Octopus
     }
-    public boolean teleportTo(ServerLevel level, double x, double y, double z, Set<Relative> relativeMovements, float yaw, float pitch, boolean setCamera, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause) {
+    public boolean teleportTo(ServerLevel level, double x, double y, double z, Set<Relative> relativeMovements, float yaw, float pitch, boolean setCamera, PlayerTeleportEvent.TeleportCause cause, Consumer<Entity> callback) { // Octopus
         // CraftBukkit end
         float f = Mth.clamp(pitch, -90.0F, 90.0F);
-        Entity entity = this.teleport(new TeleportTransition(level, new Vec3(x, y, z), Vec3.ZERO, yaw, f, relativeMovements, TeleportTransition.DO_NOTHING, cause)); // CraftBukkit
+        Entity entity = this.teleport(new TeleportTransition(level, new Vec3(x, y, z), Vec3.ZERO, yaw, f, relativeMovements, TeleportTransition.DO_NOTHING, cause), callback); // CraftBukkit // Octopus
         return entity != null;
     }
 
@@ -4248,8 +_,8 @@
     public void stopSeenByPlayer(ServerPlayer serverPlayer) {
         // Paper start - entity tracking events
         // Since this event cannot be cancelled, we should call it here to catch all "un-tracks"
-        if (io.papermc.paper.event.player.PlayerUntrackEntityEvent.getHandlerList().getRegisteredListeners().length > 0) {
-            new io.papermc.paper.event.player.PlayerUntrackEntityEvent(serverPlayer.getBukkitEntity(), this.getBukkitEntity()).callEvent();
+        if (PlayerUntrackEntityEvent.getHandlerList().getRegisteredListeners().length > 0) {
+            new PlayerUntrackEntityEvent(serverPlayer.getBukkitEntity(), this.getBukkitEntity()).callEvent();
         }
         // Paper end - entity tracking events
     }
@@ -4285,7 +_,7 @@
     }
 
     @Nullable
-    public net.minecraft.world.entity.LivingEntity getControllingPassenger() {
+    public LivingEntity getControllingPassenger() {
         return null;
     }
 
@@ -4438,13 +_,13 @@
         }
 
         @Override
-        public org.bukkit.command.CommandSender getBukkitSender(CommandSourceStack wrapper) {
+        public CommandSender getBukkitSender(CommandSourceStack wrapper) {
             return Entity.this.getBukkitEntity();
         }
 
         @Override
         public boolean acceptsSuccess() {
-            return ((ServerLevel) Entity.this.level()).getGameRules().getBoolean(net.minecraft.world.level.GameRules.RULE_SENDCOMMANDFEEDBACK);
+            return ((ServerLevel) Entity.this.level()).getGameRules().getBoolean(GameRules.RULE_SENDCOMMANDFEEDBACK);
         }
 
         @Override
@@ -4491,7 +_,7 @@
         final AABB boundingBox = this.getBoundingBox().deflate(1.0E-3);
 
         final Level world = this.level;
-        final int minSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinSection(world);
+        final int minSection = WorldUtil.getMinSection(world);
 
         final int minBlockX = Mth.floor(boundingBox.minX);
         final int minBlockY = Math.max((minSection << 4), Mth.floor(boundingBox.minY));
@@ -4499,7 +_,7 @@
 
         // note: bounds are exclusive in Vanilla, so we subtract 1 - our loop expects bounds to be inclusive
         final int maxBlockX = Mth.ceil(boundingBox.maxX) - 1;
-        final int maxBlockY = Math.min((ca.spottedleaf.moonrise.common.util.WorldUtil.getMaxSection(world) << 4) | 15, Mth.ceil(boundingBox.maxY) - 1);
+        final int maxBlockY = Math.min((WorldUtil.getMaxSection(world) << 4) | 15, Mth.ceil(boundingBox.maxY) - 1);
         final int maxBlockZ = Mth.ceil(boundingBox.maxZ) - 1;
 
         final boolean isPushable = this.isPushedByFluid();
@@ -4519,11 +_,11 @@
         final int minChunkZ = minBlockZ >> 4;
         final int maxChunkZ = maxBlockZ >> 4;
 
-        final net.minecraft.world.level.chunk.ChunkSource chunkSource = world.getChunkSource();
+        final ChunkSource chunkSource = world.getChunkSource();
 
         for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
             for (int currChunkX = minChunkX; currChunkX <= maxChunkX; ++currChunkX) {
-                final net.minecraft.world.level.chunk.LevelChunkSection[] sections = chunkSource.getChunk(currChunkX, currChunkZ, net.minecraft.world.level.chunk.status.ChunkStatus.FULL, false).getSections();
+                final LevelChunkSection[] sections = chunkSource.getChunk(currChunkX, currChunkZ, ChunkStatus.FULL, false).getSections();
 
                 // bound y
                 for (int currChunkY = minChunkY; currChunkY <= maxChunkY; ++currChunkY) {
@@ -4531,13 +_,13 @@
                     if (sectionIdx < 0 || sectionIdx >= sections.length) {
                         continue;
                     }
-                    final net.minecraft.world.level.chunk.LevelChunkSection section = sections[sectionIdx];
+                    final LevelChunkSection section = sections[sectionIdx];
                     if (section.hasOnlyAir()) {
                         // empty
                         continue;
                     }
 
-                    final net.minecraft.world.level.chunk.PalettedContainer<net.minecraft.world.level.block.state.BlockState> blocks = section.states;
+                    final PalettedContainer<BlockState> blocks = section.states;
 
                     final int minXIterate = currChunkX == minChunkX ? (minBlockX & 15) : 0;
                     final int maxXIterate = currChunkX == maxChunkX ? (maxBlockX & 15) : 15;
@@ -4779,7 +_,7 @@
         // Paper end - Block invalid positions and bounding box
         // Paper start - Fix MC-4
         if (this instanceof ItemEntity) {
-            if (io.papermc.paper.configuration.GlobalConfiguration.get().misc.fixEntityPositionDesync) {
+            if (GlobalConfiguration.get().misc.fixEntityPositionDesync) {
                 // encode/decode from ClientboundMoveEntityPacket
                 x = Mth.lfloor(x * 4096.0) * (1 / 4096.0);
                 y = Mth.lfloor(y * 4096.0) * (1 / 4096.0);
@@ -4806,7 +_,7 @@
         }
         // Paper start - Block invalid positions and bounding box; don't allow desync of pos and AABB
         // hanging has its own special logic
-        if (!(this instanceof net.minecraft.world.entity.decoration.HangingEntity) && (forceBoundingBoxUpdate || this.position.x != x || this.position.y != y || this.position.z != z)) {
+        if (!(this instanceof HangingEntity) && (forceBoundingBoxUpdate || this.position.x != x || this.position.y != y || this.position.z != z)) {
             this.setBoundingBox(this.makeBoundingBox());
         }
         // Paper end - Block invalid positions and bounding box
@@ -4891,25 +_,25 @@
     }
 
     @Nullable
-    public Entity.RemovalReason getRemovalReason() {
+    public RemovalReason getRemovalReason() {
         return this.removalReason;
     }
 
     @Override
-    public final void setRemoved(Entity.RemovalReason removalReason) {
+    public final void setRemoved(RemovalReason removalReason) {
         // CraftBukkit start - add Bukkit remove cause
         this.setRemoved(removalReason, null);
     }
 
     @Override
-    public final void setRemoved(Entity.RemovalReason removalReason, org.bukkit.event.entity.EntityRemoveEvent.Cause cause) {
+    public final void setRemoved(RemovalReason removalReason, EntityRemoveEvent.Cause cause) {
         // Paper start - rewrite chunk system
-        if (!((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)this.level).moonrise$getEntityLookup().canRemoveEntity((Entity)(Object)this)) {
+        if (!((ChunkSystemLevel)this.level).moonrise$getEntityLookup().canRemoveEntity((Entity)(Object)this)) {
             LOGGER.warn("Entity " + this + " is currently prevented from being removed from the world since it is processing section status updates", new Throwable());
             return;
         }
         // Paper end - rewrite chunk system
-        org.bukkit.craftbukkit.event.CraftEventFactory.callEntityRemoveEvent(this, cause);
+        CraftEventFactory.callEntityRemoveEvent(this, cause);
         // CraftBukkit end
         final boolean alreadyRemoved = this.removalReason != null; // Paper - Folia schedulers
         if (this.removalReason == null) {
@@ -4920,7 +_,7 @@
             this.stopRiding();
         }
 
-        if (this.removalReason != Entity.RemovalReason.UNLOADED_TO_CHUNK) { this.getPassengers().forEach(Entity::stopRiding); } // Paper - rewrite chunk system
+        if (this.removalReason != RemovalReason.UNLOADED_TO_CHUNK) { this.getPassengers().forEach(Entity::stopRiding); } // Paper - rewrite chunk system
         this.levelCallback.onRemove(removalReason);
         this.onRemoval(removalReason);
         // Paper start - Folia schedulers
@@ -4954,7 +_,7 @@
     public boolean shouldBeSaved() {
         return (this.removalReason == null || this.removalReason.shouldSave())
             && !this.isPassenger()
-            && (!this.isVehicle() || !((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)this).moonrise$hasAnyPlayerPassengers()); // Paper - rewrite chunk system
+            && (!this.isVehicle() || !((ChunkSystemEntity)this).moonrise$hasAnyPlayerPassengers()); // Paper - rewrite chunk system
     }
 
     @Override
